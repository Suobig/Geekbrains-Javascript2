# Введение в AJAX и COMET
## Что такое AJAX
AJAX - технология обращения к серверу без перезагрузки страницы.
За счет этого по интерактивности веб-приложение начинает напоминать десктоп
# Что можно делать с помощью AJAX
* Элементы интерфейса
* Динамическая подгрузка страницы
* Живой поиск
* Технически - можно обмениваться любыми данными с сервером
## Что такое COMET
COMET - общий термин, описывающий различные техники получения данных по инциативе сервера.

Можно сказать, что эт непрерывный канал с сервером
Примеры COMET-приложений:
* чат
* акуцион с онлайн обновлением ставок
* интерфейс совместного редактирования документов

На текущий момент COMET удобно реализуется в любых браузерах.

В данной статье технологии будут использоваться на низком уровне, хотя есть библиотеки и фреймворки для более высокоуровневого использования:
* Socket.io
* CometD
* etc.

## Основы XMLHttpRequest
### Основные методы:

#### 1. Настроить: open
Синтаксис: 

    xhr.open(method, URL, async, user, password);
* **method** - HTTP-метод. Как правило GET или POST
* **URL** - Адрес запроса. Может быть как http:// так и ftp:// и file://. При этом есть ограничение безопасности Same Origin Policy (SOP) - страница может отправлять запросы можно отправлять только она тот же *протокол://домен:порт* с которого она пришла.
* **async** - если установлено в *false*, то запрос происходит синхронно, если *true* - асинхронно.
* **user**, **password** - логин и пароль для HTTP авторизации, если надо.

#### 2. Отослать данные: send
Синтаксис:

    xhr.send([body]);

Именно этот метод открывает соединение и отправляет запрос на сервер. 
В **body** может находиться тело запроса. Тело есть не у всех запросов, например, у GET запроса нет тела, а вот у POST основные данные передаются именно через body.

#### 3. Отмена: abort
Вызов 

    xhr.abort();

приведет к прерыванию выполнения запроса.

#### 4. Ответ: status, statusText, responseText

**xhr.status**  - код ответа: 202, 404, 403 и т.д. Может быть равен 0, если сервер не ответил или при попытке запроса на другой домен.

**xhr.statusText** - Текстовое описание статуса от сервера: OK, Not Found, Forbidden и т.д.

**responseText** - Текст ответа от сервера

**responseXML** - если сервер вернул XML документ, снабдив его корректным заголовком Content-type: text/xml, то браузер создаст из него XML-документ. По нему можно будет делать запросы через querySelector и т.д. Используется редко, т.к. сервер обычно возвращает JSON а не XML.

### Синхронные и асинхронные запросы

Если в методе open параметр async установлен равным false, то запрос будет синхронным. 

Синхронные запросы используются крайне редко, так как блокируют работу со страницей до окончания загрузки данных по запросу. Если синхронный запрос занимает слишком много времени, браузер предложит закрыть "зависшую" страницу. 

Кроме того, ряд возможностей, такие как  возможность делать запросы на другой домен или указывать таймаут, в синхронном режиме работать не будут. 

### События readystatechange
Событие происходит несколько раз в процессе отсылки и получения ответа. 

Состояния:

    const unsigned short UNSENT = 0; // начальное состояние
    const unsigned short OPENED = 1; // вызван open
    const unsigned short HEADERS_RECEIVED = 2; // получены заголовки
    const unsigned short LOADING = 3; // загружается тело (получен очередной пакет данных)
    const unsigned short DONE = 4; // запрос завершён

Последовательность смены состояний 0 -> 1 -> 2 -> 3 -> ... -> 3 -> 4

Состояние 3 может повторяться несколько раз - при каждом получении нового пакета данных. 

Теоретически, мы могли бы использовать текущее значение responseText, полученное на третьем этапе, как "ответ на текущий момент". Однако это связано с проблемами, т.к. мы не контролируем место разрыва. Например, в некоторых кодировках разрыв может произойти посредине символа, если тот кодируется несколькими байтами. 

### HTTP-заголовки
XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать полученные от сервера заголовки.

Для работы с заголовками есть 3 метода:

#### 1. setRequestHeader(name, value)
Ограничения:
* нельзя устанавливать заголовки, которые контролирует браузер, например Referer или Host и ряд других
* проставленный заголовок нельзя снять 

#### 2. getResponseHeader(name);
Возвращает значение заголовка ответа (кроме Set-Cookie и Set-Cookie2)

#### 3. getAllResponseHeaders();
Возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2. Заголовки возвращаются в виде единой строки. Заголовки разделяются символами "\r\n". Значение заголовка отделяет двоеточием.


### Таймаут

Таймаут задает максимальную продолжительность асинхронного запроса:

    xhr.timeout = 30000; // 30 seconds

При превышении этого времени будет сгенерировано событие ontimeout.

### Полный список событий

* loadstart - запрос начат
* progress - получен очередной пакет данных, который можно прочитать в responseText
* abort - запрос отменен вызовом xhr.abort()
* error - произошла ошибка
* load - запрос был успешно завершен
* timeout - запрос был прекращен по таймауту
* loadend - запрос завершен (успешно или неуспешно)

Используя эти события можно более удобно отслеживать загрузку (onload) процесс загрузки (onprogress) и т.д.

### IE 8, 9: XDomainRequest

В IE 8 и 9 поддаржка XMLHttpRequest ограничена, поэтому разработчики создали свой объект XDomainRequest, который реализовал часть возможностей современного стандарта.

### IE 9- и кеширование

Обычно ответы на запросы кешируются, как и обычные старинцы. Но IE9 по умолчанию кеширует все ответы, не снабженные антикеш-заголовком. Другие браузеры этого не делают. 

Чтобы избежать кеширования, сервер добавляет в ответ соответствующие антикеш-заголовки, например, Cache-control: no-cache. 

Альтернативный вариант - добавить в URL запроса случайный параметр, который позволит избежать кеширования. Раньше такой вариант использовался часто, т.к. браузеры плохо поддерживали кеширующие заголовки. Сейчас заголовки поддерживаются нормально.

## XMLHttpRequest POST, формы и кодировка

При отправки \<form\> браузер собирает значения полей, формирует из них строку и составляет тело GET или POST запроса. 

При отправке формы через XMLHttpRequest это надо делать самостоятельно в JS. 